local variants = require "main.entities.person.defs._variants"
local goal_factory = require 'main.ai.goal_factory'
local kinematic_controller = require 'main.physics.kinematic_controller'
local tilemap_helper = require 'helpers.tilemap'
local brain = require 'main.ai.brain'

go.property("variant", hash("normal1"))

local function play_animation(self, anim, hflip)
    if self.animation ~= anim then
        sprite.play_flipbook("#sprite", anim)
        self.animation = anim
    end

    if hflip ~= nil then
        sprite.set_hflip("#sprite", hflip)
    end
end

local function animate(self)
    if self.controller.is_grounded then
        if self.controller.velocity.x == 0 then
            play_animation(self, self.def.anim.idle)
        else
            play_animation(self, self.def.anim.run, self.facing == -1)
        end
    else
        play_animation(self, self.def.anim.fall)
    end
end

local function print_debug(self)
    local pos = vmath.vector3(10, 720 - 30, 0)
    local line_diff = vmath.vector3(0, -20, 0)

    local lines = {
        '-- person --',
        'state: ' .. self.state,
        'animation: ' .. self.animation,
        '-- brain --',
        'current_goal: ' .. (self.brain.current_goal.type) .. " status:" .. (self.brain.current_goal.status),
        'goals left: ' .. #self.brain.goals,
        '-- controller --',
        'position' .. go.get_position(),
        'velocity: ' .. self.controller.velocity.x .. ',' .. self.controller.velocity.y,
        'grounded: ' .. tostring(self.controller.is_grounded),
        'correction:' .. self.controller.correction.x .. ',' .. self.controller.correction.y,
        'on slope: ' .. tostring(self.controller.is_on_slope),
    }

    for i, str in ipairs(lines) do
        msg.post("@render:", "draw_text", {
            text = str,
            position = pos + (i - 1) * line_diff,
            color = vmath.vector4(1, 1, 1, 1)
        })
    end
end

function on_goal_blocked(self, goal)
    sprite.play_flipbook('#indicator_sprite', 'question')
    timer.delay(3, false, function(obj)
        self.brain:cancel_current_goal()
        sprite.play_flipbook('#indicator_sprite', 'none')
    end)
end

function init(self)
    self.type = hash("person")
    self.def = variants[self.variant]

    self.animation = self.def.anim.idle

    self.controller = kinematic_controller.new({
        collision_groups = { hash('floor'), hash('helipad') }
    })
    self.brain = brain.new(self, on_goal_blocked)

    self.speed = self.def.speed
    self.state = hash('goal') -- goal, fall, confused

    msg.post("#", "add_goal", {
        type = 'move',
        position = tilemap_helper.tile_to_world_position(21, 14)
    })
end

function fixed_update(self, dt)
    self.controller:fixed_update_start(dt)

    self.brain:fixed_update(dt)

    self.controller:fixed_update_end(dt)
end

function update(self, dt)
    print_debug(self)

    if not self.controller.is_grounded then
        self.state = hash('fall')
        self.controller.velocity.x = 0
        return
    end

    self.brain:update(dt)
end

function late_update(self, dt)
    animate(self)
    self.controller:late_update(dt)
    self.state = hash('goal')
end

function on_message(self, message_id, message, sender)
    if message_id == hash('add_goal') then
        self.brain:add_goal(message)
    end

    if message_id == hash('contact_point_response') then -- and message.other_group == hash('floor') then
        self.controller:on_contact(message)
    end

    if message_id == hash('start_animation') then
        play_animation(self, message.anim, message.hflip)
    end
end
