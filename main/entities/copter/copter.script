local width = 40
local height = 40


local HELICE_LOCAL_OFFSET = vmath.vector3(0, height, 0)

local YVECT = vmath.vector3(0, 1, 0)
local NEG_YVECT = vmath.vector3(0, -1, 0)
local XVECT = vmath.vector3(1, 0, 0)
local NEG_XVECT = vmath.vector3(-1, 0, 0)

-- Apply torque to a dynamic collision object component
function apply_torque(url, worldpos, f, size)
    local halfp = f / 2
    local half_size = size / 2
    msg.post(url, "apply_force", { force = NEG_XVECT * halfp, position = worldpos + NEG_YVECT * half_size })
    msg.post(url, "apply_force", { force = XVECT * halfp, position = worldpos + YVECT * half_size })
end

function init(self)
    self.engine_power = 7000
    self.torque_power = 400

    self.input_throttle = 0
    self.input_pitch = 0

    self.throttle = 0

    self.extra_weight = 0
end

function fixed_update(self, dt)
    local helice_pos = go.get_position() + vmath.rotate(go.get_rotation(), HELICE_LOCAL_OFFSET)
    local up_dir = vmath.normalize(helice_pos - go.get_position())

    if self.input_throttle ~= 0 then
        self.throttle = self.throttle + self.input_throttle * dt * 0.8
        if self.throttle > 1 then self.throttle = 1 end
        if self.throttle < 0 then self.throttle = 0 end
    else
        -- PD controller
        local mass = go.get("#co", "mass") + self.extra_weight
        local hover_force = mass * -physics.get_gravity().y
        self.throttle = hover_force / self.engine_power
    end

    --print(self.throttle)
    if (self.throttle > 0) then
        local force_vec = up_dir * self.throttle * self.engine_power

        -- msg.post("@render:", "draw_line", {
        -- 	start_point = helice_pos,
        -- 	end_point = helice_pos + (up_dir * 50),
        -- 	color = vmath.vector4(1,1,1,1)
        -- })
        -- msg.post("@render:", "draw_line", {
        -- 	start_point = helice_pos,
        -- 	end_point = helice_pos + (up_dir * 50 * self.throttle),
        -- 	color = vmath.vector4(0,1,0,1)
        -- })

        msg.post("#co", "apply_force", { force = force_vec, position = helice_pos })
    end

    local center = go.get_position() + vmath.rotate(go.get_rotation(), vmath.vector3(0, height / 2, 0))
    if self.input_pitch ~= 0 then
        apply_torque("#co", center, self.input_pitch * self.torque_power, height)
    else
        -- angle controller
        local angle = go.get(".", "euler.z") --[[@as number]]
        --print(angle)
        if math.abs(angle) < 1 then angle = 0 end
        if angle ~= 0 then
            local angle_correction_dir = 0
            if angle > 0 then angle_correction_dir = 1 elseif angle < 0 then angle_correction_dir = -1 end
            apply_torque("#co", center, angle_correction_dir * 0.3 * self.torque_power, height)
        end
    end
end

function on_message(self, message_id, message, sender)
    --print(message_id)
    if message_id == hash('throttle_up') then
        self.input_throttle = self.input_throttle + 1
    end
    if message_id == hash('throttle_down') then
        self.input_throttle = self.input_throttle - 1
    end
    if self.input_throttle > 1 then self.input_throttle = 1 end
    if self.input_throttle < -1 then self.input_throttle = -1 end
    --print(self.input_throttle)

    if message_id == hash('pitch_right') then
        self.input_pitch = self.input_pitch + 1
    end
    if message_id == hash('pitch_left') then
        self.input_pitch = self.input_pitch - 1
    end
    if self.input_pitch > 1 then self.input_pitch = 1 end
    if self.input_pitch < -1 then self.input_pitch = -1 end

    if message_id == hash('box_attached') then
        -- pprint('box attached!', message)
        self.extra_weight = go.get(msg.url(nil, message.box_id, "co"), "mass")
    end
    if message_id == hash('box_detached') then
        -- pprint('box detached!', message)
        self.extra_weight = 0
    end

    if message_id == hash('tilt') then
        local rand_vel = vmath.normalize(vmath.vector3(-1 + 2 * math.random(), -1 + 2 * math.random(), 0))
        local rand_rot
        if math.random() > 0.5 then rand_rot = 1 else rand_rot = -1 end
        local center = go.get_position() + vmath.rotate(go.get_rotation(), vmath.vector3(0, height / 2, 0))
        apply_torque("#co", center, rand_rot * 50000, height)
        msg.post("#co", "apply_force",
            {
                force = rand_vel * 60000,
                position = go.get_position()
            })
    end

    if message_id == hash('contact_point_response') and message.other_group == hash('floor') then
        return true
    end

    -- if message_id == hash("collision_response") then
    -- 	-- take action
    -- 	--print("I collided with", message.other_id)
    -- 	print("collision_response", message.other_group, go.get_position().x)
    -- end
    -- if message_id == hash("contact_point_response") then
    -- 	print("contact_point_response", message.other_group, go.get_position().x)
    -- end
end

function on_reload(self)
end
